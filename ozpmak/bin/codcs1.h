//---------------------------------------------------------------------------
//  CSCOM.H:
//---------------------------------------------------------------------------
ex  us  far THR;
ex  us  far RDR;
ex  us  far BRDL;
ex  us  far BRDH;
ex  us  far IER;
ex  us  far IIR;
ex  us  far FCR;
ex  us  far LCR;
ex  us  far MCR;
ex  us  far LSR;
ex  us  far MSR;
ex  us  far SCR;
//---------------------------------------------------------------------------
ex  ui  far COM_DTR [MCOM];
ex  ui  far COM_RTS [MCOM];
ex  ui  far COM_OUT1[MCOM];
ex  ui  far COM_OUT2[MCOM];
//  флаги включения сигналов линии DTR,RTS,OUT1,OUT2
//---------------------------------------------------------------------------
ex  uc  far ICTStat[MCOM];
//  Байт регистра статуса при посылки данных в порт
//---------------------------------------------------------------------------
ex  uc  far OutChar[MCOM];
//  Текущий посылаемый в COM порт байт
//---------------------------------------------------------------------------
ex  uc  far TempB  [MCOM];
ex  uc  far SaveB  [MCOM];
//  Временные переменные
//---------------------------------------------------------------------------
ex  uc  far COM_ReadBuff[MCOM][RBFSZ];
//  Буфер приема
//---------------------------------------------------------------------------
ex  uc  far COM_SendBuff[MCOM][RBFSZ];
//  Буфер передачи
//---------------------------------------------------------------------------
ex  ui  far COM_HRB [MCOM];
ex  ui  far COM_TRB [MCOM];
//  Указатель в буфере приема
//---------------------------------------------------------------------------
ex  ui  far COM_HSB [MCOM];
//  Указатель в буфере передачи
//---------------------------------------------------------------------------
ex  ui  far COM_CSB[MCOM];
//  Общее количество символов для передачи в буфере
//---------------------------------------------------------------------------
ex  ui far CSBLEN;
//  Длинна посылаемой строки
//---------------------------------------------------------------------------
ex  ui  far COM_FIFO[MCOM];
//  Флаги использования буфера FIFO для портов (0-выключен)
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  CSCOM.C:
//---------------------------------------------------------------------------
ex  vd  far ComRegSetAddr(ui far p);
ex  ui  far InstallCom(ui far p, ui far Baud, ui far Data, ui far Chet, ui far Stop);
//  Установка нового вектора прерывания для указанного COM порта
//  p - номер COM порта для которого устанавливается прерывание (1-COM1)
//---------------------------------------------------------------------------
ex  ui  far ComSetMCR(ui far Port, ui far fDTR, ui far fRTS, ui far fOUT1, ui far fOUT2);
//  Установка регистра MCR (Modem Control Register) (BaseIO+4) (0x3fc)
//  Port - номер COM порта для которого делаются устанавливается
// COM1 IRQ=4 IOBase=0x3f8 ; COM2 IRQ=3 IOBase=0x2f8 ;
// COM3 IRQ=5 IOBase=0x3e8 ; COM4 IRQ=7 IOBase=0x2e8 ;
//---------------------------------------------------------------------------
ex  vd  far RestoreCom(ui far Port);
//  Установка старого вектора прерываний для COM портов
//  Port - номер COM порта для которого устанавливается прерывание (1-COM1)
//---------------------------------------------------------------------------
ex  vd  far InfoSetCom(ui far Port);
//  Информация о текущих установках COM порта
//  Port - номер COM порта для которого выводитяся информация (1-COM1)
//---------------------------------------------------------------------------
ex  _i  far IsCom(ui far Port);
//  Проверка присутствия в буфере приема принятых символов
//  Возврат: 1-есть данные в буфере,   0-нет данных в буфере
//---------------------------------------------------------------------------
ex  uc  far ReadCom(ui far Port);
//  Чтение данных из буфера приема
//  Возврат: Текущий символ из буфера
//---------------------------------------------------------------------------
ex  vd  far COMOut(ui far Port);
//  Посылка символов через указанный COM порт
//---------------------------------------------------------------------------
ex  int far ToComStr(ui far Port, uc far *Str);
//  Посылка строки через указанный COM порт
//  Port - номер COM порта для посылки данных (1-COM1...)
//  Str  - посылаемая строка
//  Возвращаемое значение:
//         1 - функция успешно завершена
//---------------------------------------------------------------------------
ex  int far ToComBufn(ui far Port, uc far Buf[RBFSZ], ui far Num);
//  Посылка определенного количества байт через указанный COM порт
//  Port - номер COM порта для посылки данных (1-COM1...)
//  Buf  - посылаемый буфер
//  Num  - определенное количество символов для посылки
//  Возвращаемое значение:
//         1 - функция успешно завершена
//---------------------------------------------------------------------------
ex  uc  far COM_BitSelect(uc far BS_Byte, ui far BS_Num);
//  Выделение указанного бита из байта
//  BS_Byte - значение байта из которого нужно выделить бит
//  BS_Num  - номер бита который нужно выделить из указанного значения байта
//---------------------------------------------------------------------------
ex  int far ClearCom (ui far Port);
//  Очистка буфера приема для указанного COM порта
//  Port - номер COM порта для которого очищается буфер приема (1-COM1)
//---------------------------------------------------------------------------
ex  vd  far COM_ClearSendBuff(ui far Port);
//  Очистка буфера передачи для указанного COM порта
//  Port - номер COM порта для которого очищается буфер приема (1-COM1)
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  CSTIM.C:
//---------------------------------------------------------------------------
ex  vd  far GetTime(int * far hour, int * far min, int * far sec);
//  получить в переменные по указанным адресам текущее время
//---------------------------------------------------------------------------
ex  vd  far GetDate(int * far year, int * far mon, int * far day);
//  получить в переменные по указанным адресам текущее время
//---------------------------------------------------------------------------
ex  vd  far SetTime(int far hour, int far min, int far sec);
//  установить в системе время из передаваемых переменных
//---------------------------------------------------------------------------
ex  vd  far SetDate(int far year, int far mon, int far day);
//  установить в системе дату из передаваемых переменных
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  NBFN.H:
//---------------------------------------------------------------------------
ex  uc  far STATUSNCB[255];
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  NBFN.C:
//---------------------------------------------------------------------------
ex  vd  far PrintNCB(ui far ncb);
//  Вывод на экран структуры NCB
//---------------------------------------------------------------------------
ex  ui  far WS_NB__Init(vd);
//  Проверка установки NETBIOS
//  Возвращаемое значение:
//           0 - NetBIOS установлен
//           1 - NetBIOS не установлен
//---------------------------------------------------------------------------
ex  vd  far WS_NB__ZeroNCB(ui far WS_CurNCB);
//  Заполнение значений текущего NCB нулями
//  WS_CurNCB- текущий  NCB (NetBIOS Control Block)
//---------------------------------------------------------------------------
ex  vd  far WS_NB__NetBios(ui far WS_CurNCB);
//  Вызов выполнения функций NETBIOS
//  WS_CurNCB- текущий NCB
//---------------------------------------------------------------------------
ex  ui  far WS_NB__AddName(_c * far WS_name,ui far WS_CurNCB);
//  Добавление имени станции в список сети NetBIOS
//  WS_name  - имя станции (до 15 символов)
//  WS_CurNCB- текущий NCB
//  Возвращаемое значение:
//               0 - успешное завершение функции
//             100 - ошибка текущего NCB
//          другое - код ошибки NetBIOS
//---------------------------------------------------------------------------
ex  ui  far WS_NB__DeleteName( _c * far WS_name,ui far WS_CurNCB );
//  Удаление имени станции из списка сети NetBIOS
//  WS_name  - имя станции (до 15 символов)
//  WS_CurNCB- текущий NCB
//  Возвращаемое значение:
//               0 - успешное завершение функции
//             100 - ошибка текущего NCB
//          другое - код ошибки NetBIOS
//---------------------------------------------------------------------------
ex  ui  far WS_NB__GetError(vd);
//  Возврат кода ошибки
//---------------------------------------------------------------------------
ex  ui  far WS_NB__GetFinalCCode(ui far WS_CurNCB);
//  Возврат завершающего кода выполнения функции NetBIOS из текущего NCB
//  WS_CurNCB- текущий NCB
//---------------------------------------------------------------------------
ex  ui  far WS_NB__GetRetCCode(ui far WS_CurNCB);
ex  ui  far WS_NB__GetNCBSize(ui far WS_CurNCB);
//  Возврат размера буфера обмена из текущего NCB
//  WS_CurNCB- текущий NCB
//---------------------------------------------------------------------------
ex  ui  far WS_NB__GetNetworkN(ui far WS_CurNCB);
//  Возврат номера имени станции в сети из текущего NCB
//  WS_CurNCB- текущий NCB
//---------------------------------------------------------------------------
ex  _c  far *WS_NB__GetCallName(ui far WS_CurNCB);
//  Возврат имени вызываемого партнера из текущего NCB
//  WS_CurNCB- текущий NCB
//---------------------------------------------------------------------------
ex  _c  far *WS_NB__GetOurName(ui far WS_CurNCB);
ex  vd  far WS_NB__SetBuffer(_c * far WS_Buf, ui far WS_BufSize, ui far WS_CurNCB);
//  Установка адреса и размера буфера приема|передачи в текущем NCB
//  WS_Buf    - указатель на буфер обмена
//  WS_BufSize- размер буфера
//  WS_CurNCB - текущий NCB
//---------------------------------------------------------------------------
ex  vd  far WS_NB__SetCallName(_c * far WS_name, ui far WS_CurNCB);
//  Установка имени вызываемой станции в текущем NCB
//  WS_name   - имя вызываемой станции
//  WS_CurNCB - текущий NCB
//---------------------------------------------------------------------------
ex  vd  far WS_NB__ReceiveDatagram(ui far WS_NetwrkNameNumber, ui far WS_CurNCB);
//  Прием датаграммы
//  WS_NetwrkNameNumber - номер имени в сети
//  WS_CurNCB - текущий NCB
//---------------------------------------------------------------------------
ex  vd  far WS_NB__SendDatagram(ui far WS_NetwrkNameNumber, ui far WS_CurNCB);
//  Посылка датаграммы
//  WS_NetwrkNameNumber - номер имени в сети
//  WS_CurNCB - текущий NCB
//---------------------------------------------------------------------------
ex  vd  far WS_NB__Receive(_c * far WS_Buffer_Name, ui far WS_Buffer_Size,ui far WS_NetworkNameNumber, ui far WS_CurNCB);
//  Прием данных из сети NetBIOS
//  WS_Buffer_Name - буфер обмена для текущего NCB
//  WS_Buffer_Size - размер буфера обмена
//  WS_NetworkNameNumber -  номер имени станции в сети
//  WS_CurNCB      - номер текущего NCB
//---------------------------------------------------------------------------
ex  vd  far WS_NB__Send(_c * far WS_Buffer_Name, ui far WS_Buffer_Size,_c * far WS_Station, ui far WS_NetworkNameNumber, ui far WS_CurNCB);
//  Посылка данных в сети NetBIOS
//  WS_Buffer_Name - буфер обмена для текущего NCB
//  WS_Buffer_Size - размер буфера обмена
//  WS_Station     - имя вызываемой станции
//  WS_NetworkNameNumber -  номер имени станции в сети
//  WS_CurNCB      - номер текущего NCB
//---------------------------------------------------------------------------
ex  vd  far WS_NB__Reset(ui far WS_Adapter, ui far WS_CurNCB);
//  Сброс установок NetBIOS
//  WS_Adapter - номер сетевого адаптера для которого сбрасываются установки
//  WS_CurNCB  - номер текущего NCB
//---------------------------------------------------------------------------
ex  vd  far WS_NB__Cancel(ui far WS_CurNCB);
//  Отмена последней команды Send__ NetBIOS
//  WS_CurNCB  - номер текущего NCB
//---------------------------------------------------------------------------
ex  _i  far WS_NB__AvNCB(vd);
//  Возвращает номер свободного NCB или -1, если свободного NCB нет
//---------------------------------------------------------------------------
ex  vd far WS_NB__PrintCCode(_i far STATVLNCB);


//---------------------------------------------------------------------------
//  NBWS.H:
//---------------------------------------------------------------------------
ex  ui  far NBStat;
//---------------------------------------------------------------------------
//  Контроль ответов от контроллеров
ex  ui  far WSANSNUM[HOWMAXWS];
ex  ui  far WSANSCNT[HOWMAXWS];
ex  ui  far WSPRVCNT[HOWMAXWS];
ex  ui  far WSHOWNUM;
ex  _i  far WSCURCNT;
//---------------------------------------------------------------------------
ex  _c  far WS_LocalS[LNAM];
ex  _c  far WS_NBName[LNAM];
//---------------------------------------------------------------------------
ex  _l far CNTANS;
ex  _i far DBN[100];
// Номера контроллеров(PCCS) для запрашиваемых каналов
ex  _i far DBC[100];
// Массив полученных значений с запрашиваемых каналов             
ex  _f far DBV[100];
// Массив счетчиков учета запросов-ответов
ex  _i far DBZ[100];
// Кол-во переменных текущего запроса
ex  ui far HNBWREQ;
// Номер текущего запроса
ex  ui far NNBWREQ;
// Флаг обработки буферов(работы) PCTCP
ex  ui far ptEX;
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  NBWS.C:
//---------------------------------------------------------------------------
ex  vd  far WS_NB_SetNumber(_c * far WSNBNS);
ex  uc  far WS_NB_GetNWS(vd);
ex  _i  far WS_NB__NetChange(vd);
//  Обмен данными в сети NetBIOS
//--------------------------------------------------------------------------
ex  vd  far WS_NB__CheckNIP(_i n);
ex  ui  far WS_NB__CheckVFN(_i nws);
ex  ui  far WS_NB__YesNoVFN(_i nws);
ex  vd  far WS_NB__Answer(ui far inncb, ui far ouncb);
//  Формирование ответного блока для сетевого ответа
//---------------------------------------------------------------------------
ex  vd  WS_NB__Answer27(ui far inncb, ui far ouncb);
//  Формирование ответного блока для сетевого ответа с номерами каналов
//--------------------------------------------------------------------------
ex  vd  far WS_NB__GetFromNet(ui far n);
//  Передача принятых из сети данных в массив обмена DBB[]
//  n - номер текущего NCB
//--------------------------------------------------------------------------
ex  ui  far InitNB(ui far Mode);
//  Инициализация NetBIOS
//---------------------------------------------------------------------------
ex  ui far WS_NB__SendDat(ui far NWS);
// Посылка данных на другие контроллеры
//--------------------------------------------------------------------------
ex  vd far WS_NB__ClearReqArr(vd);
//--------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  REGUL.H:
//---------------------------------------------------------------------------
ex  _f  far WO_Skip[NREGUL];
// Возвращаемое регулятором значение для передачи в программу пользователя
// (для 'безударного' перехода регулятора в ручной и автоматический  режимы)
//---------------------------------------------------------------------------
ex  _f  far OutX[NREGUL];
ex  _f  far OutO[NREGUL];
// выход регулятора из аналоговой части
//---------------------------------------------------------------------------
ex  _f  far ImpLC[NREGUL];
// счетчик длинны импульса
//---------------------------------------------------------------------------
ex  _f  far ImpWC[NREGUL];
// счетчик длинны паузы между импульсами
//---------------------------------------------------------------------------
ex  _f  far RetO[NREGUL];
// дискретный выход регулятора с прошлого шага
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  REGUL.C:
//---------------------------------------------------------------------------
ex  vd  far RegulatorInit(vd);
//  Обнуление флагов регуляторов
//---------------------------------------------------------------------------
ex  _f  far Regulator(ui far n,  _f far Inp, _f far KP, _f far KI, _f far KD, _f far TI, _f far KO, _f far KA, _f far ZL,  _f far ZH, _f far IL, _f far IH, _f far OL, _f far OH, _f far DM, _f far ZN,  _f far PR, _f far CC, _f far FL);
//  n       номер регулятора
//  Inp     текущее значение регулируемого параметра
//  KP,KI,KD,TI   коэф.регул KP-пропорц,KI-интегр,KD-дифференц,TI-время изодрома
//  KO      ручное управление
//  KA      переключение ручное-автомат (1-автомат,0-ручное)
//  ZL,ZH   задание регулятора
//  IL,IH   входная шкала регулятора  (шкала регулируемого параметра)
//  OL,OH   выходная шкала регулятора
//  DM      MAX приращение регулятора
//  ZN      зона нечуствительности
//  PR      процент рассогласования для включения контрольного цикла
//  CC      контрольный цикл (ч/з сколько циклов будет включаться контр.цикл)
//  FL      тип регулятора
//          5 - только текущий шаг регулятора (рассогласование без приращения)
//  Возвращаемое значение:
//          выход регулятора
//---------------------------------------------------------------------------
ex  _f  far RegulDigit(ui far n, _f far KDP, _f far KDW, _f far KMas, _f far ModRA, _f far OutM);
//  Преобразование аналогового выхода в дискретный
//  n    - номер регулятора
//  KDP  - коэффициент длинны импульса
//  KDW  - коэффициент длинны паузы
//  KMas - коэффициент масштаба
//  ModRA- режим работы регулятора (ручное-автомат)
//  OutM - выход ручного управления регулятора
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  IMOD.H:
//---------------------------------------------------------------------------
ex  ui  far HMCF[MCOM];
//  количество записей описаний модулей
//---------------------------------------------------------------------------
ex  uc  far PCCA[4];
//  адрес контроллера в сети
//---------------------------------------------------------------------------
ex  ui  far RecvTO [MCOM];
ex  ui  far RecvCmd[MCOM];
//  флаг приема данных из порта (когда идет прием данных из портов
//  COM1|COM2|COM3|COM4 порядковый номер флага устанавливается в 1 и более)
//---------------------------------------------------------------------------
ex  ui  far SendTO [MCOM];
ex  ui  far COMWT  [MCOM];
//  Текущее значение паузы (циклов) между посылками в порт
//---------------------------------------------------------------------------
ex  ui  far COMTO  [MCOM];
//  количество циклов таймаута опроса модулей
//---------------------------------------------------------------------------
ex  ui  far COMCH  [MCOM];
//  флаги использования портов
//  0-порт не используется (NOU)
//  1-порт используется для обмена с модулями УСО (USO)
//  2-порт используется для обмена с рабочими станциями в режиме SLAVE (WST)
//---------------------------------------------------------------------------
ex  ui  far HEXF[MCOM];
//  флаг приема от AI модулей ответов HEX или % формате (1=HEX)
//---------------------------------------------------------------------------
ex  uc  far ReadBF [MCOM][RBFSZ];
ex  uc  far SendBT [MCOM][RBFSZ];
ex  uc  far TempBF [MCOM][14];
//  буфер для приема данных (запросов)
//---------------------------------------------------------------------------
ex  ui  far ReadCB [MCOM];
ex  ui  far SendCB [MCOM];
//  номер текущего байта в буфере чтения
//---------------------------------------------------------------------------
ex  ui  far ReadED [MCOM];
//  флаг окончания чтения данных из порта
//---------------------------------------------------------------------------
ex  ui  far VAGIFLG[MCOM];
//  флаг работы с прибором ВАГИ
//---------------------------------------------------------------------------
ex  ui  far VAGICNT[MCOM];
//  счетчик текущего символа ответа от прибора ВАГИ
//---------------------------------------------------------------------------
ex  uc  far VAGISTR[MCOM][VAGSLEN];
//  строки ответов от приборов
//---------------------------------------------------------------------------
ex  uc  far TRM_bf[MCOM][100];
ex  ui  far TRM_q [MCOM];
ex  ui  far TRM_c [MCOM];
ex  ui  far TRMDEB[MCOM];
//---------------------------------------------------------------------------
ex  us TRM_HV ;
ex  uc TRM_cr1;
ex  uc TRM_cm1;
ex  uc TmpCRC[1024], VReadBuff[1024];
// Переменные для функций работы с приборами OWEN
//----------------------------------------------------------------------------
// Таблица хеширования
ex  uc far HashCHR[40];
ex  uc far HashVAL[40];
ex  uc far TetrCHR[16];
ex  uc far TetrVAL[16];
ex  uc far *HashCST[MAXHC];
ex  us far HashCVL[MAXHC];


//---------------------------------------------------------------------------
//  IMOD.C:
//---------------------------------------------------------------------------
ex  vd  far WS_SP_SetNumber(_c * far WSSPNS);
//  установка номера рабочей станции для сети RS485
//--------------------------------------------------------------------------
ex  vd far PrintBin(us vl);
// Вывод бобитно байтов на экран
//----------------------------------------------------------------------------
ex  us far OWEN_CnvA2OCF(uc bits, int f, int b, int e, uc * acmd);
// Функция конвертирования строки из ASCII формата  в
// Owen Character Format.  Возвращает OWEN-hash-код переданной строки.
//----------------------------------------------------------------------------
ex  uc far OWEN_CnvB2OTT(char n, char c);
// Функция преобразования байта в OWEN-тетраду
//----------------------------------------------------------------------------
ex  us far OWEN_GetHash(uc Byte, uc nbit, us CRC);
// Функция преобразования символа из Owen Character Format в Owen-hash-код
//----------------------------------------------------------------------------
ex  vd far OWEN_GetCRC(uc bits, int f, int b, int e, uc * acmd);
// Вызов подсчета контрольной суммы запроса для прибора OWEN TPM138
//----------------------------------------------------------------------------
ex  uc far OWEN_OTT2CnvB(char c1, char c2);
// Преобразование OWEN тетрады в байт данных
//----------------------------------------------------------------------------
ex  vd  far CheckTimeOut(ui far p);
ex  ui  far CheckCRC(ui far p);
//  проверка CRC (1-совпадает, 0-нет)
//---------------------------------------------------------------------------
ex  vd  far ConvertRead(ui far p);
//  преобразование ответов от модулей УСО
//---------------------------------------------------------------------------
ex  vd  far SendCMD(ui far p);
//  посылка комманд на модули УСО
//---------------------------------------------------------------------------
ex  vd  far ClearR(_i far p);
ex  vd  far ClearS(_i far p);
ex  _i  far ReadANS(ui far p);
//  прием ответов от модулей УСО и запросов от рабочих станций
//---------------------------------------------------------------------------
ex  ui  far TestREQ(ui far p);
//  Прием данных от рабочей станции и ответ на запрос (если был запрос)
//---------------------------------------------------------------------------
ex  _i  far SetMODV(uc far p, uc far r, uc far c,  _f far v,  _f far ld, _f far hd);
//  Установить значение на указанном канале:
//  p     - номер COM-порта
//  r     - номер записи в массиве определений модулей
//  c     - номер ячейки в записи
//  v     - устанавливаемое значение (0-100%)
//  ld,hd - нижняя и верхняя границы диапазона выхода в %
//          (0..25% - 0..5mA, 20..100% - 4..20mA, 0..100% - 0..20mA)
//---------------------------------------------------------------------------
ex  _i  far SetMODC(ui far p, ui far r, ui far t, uc * far c, ui far l, ui far a);
//  p  - номер COM порта
//  r  - номер записи для массива определения модулей
//  t  - тип модуля
//  c  - комманда для модуля
//  l  - длинна комманды
//  a  - количество переменных ответов
//  Возврат: 0-нет ошибок в установке, меньше 0- есть ошибки...
//---------------------------------------------------------------------------
ex  _i  far SetMODF(ui far p, ui far r, uc far f, _i far v);
//  p  - COM порт
//  r  - номер записи в массиве определения модулей
//  f  - устанавливаемое поле 'e'-ошибок, 'o'-правильных ответов
//  v  - значение для устанавливаемого поля
//  Возвращает 0, если значение установленно или -1, если
//  установки определены неверно
//---------------------------------------------------------------------------
ex  _i  far GetMODF(ui far p, ui far r, uc far f);
//  p  - COM порт
//  r  - номер записи в массиве определения модулей
//  f  - запрашиваемое поле 'e'-ошибки, 'o'-правильные ответы
//  Возвращает значение запрашиваемого поля указанной  записи или -1,
//  если установки определены неверно
//---------------------------------------------------------------------------
ex  _f  far GetMODV(ui far p, ui far r, uc far n);
//  p  - COM порт
//  r  - номер записи в массиве определения модулей
//  n  - номер переменной из массива определения модулей (номер канала модуля)
//  Возвращает значение запрашиваемого канала модуля
//---------------------------------------------------------------------------
ex  _i  far PrnMODC(ui far p, ui far r, ui far m);
//  p  - COM порт
//  r  - номер записи в массиве определения модулей
//  m  - режим вывода информации
//  Выводит информацию о конфигурации модуля указанной записи
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  MONITOR.H:
//---------------------------------------------------------------------------
ex  _i  far MonCHN[20];
//  Номера каналов для отображения
//---------------------------------------------------------------------------
ex  _i  far MonFirst;
//  Флаг первого вызова монитора
//---------------------------------------------------------------------------
ex  _i  far MonCPos;
//  Текущая позиция в буфере ввода комманды
//---------------------------------------------------------------------------
ex  uc  far SCMD[MAXSTRE];
ex  _c  far pVERSION[MAXSTRE];
ex  _c  far nVERSION[MAXSTRE];
//---------------------------------------------------------------------------
ex  ui  far BusyTer;
//  флаг занятости порта
//---------------------------------------------------------------------------
ex  ui  far AddrrBeg;
ex  ui  far AddrrEnd;
//  адрес модулей для поиска
//---------------------------------------------------------------------------
ex  ui  far CRCF[5];
//  флаги разрешения учета контрольных сумм в терминальных операциях
//---------------------------------------------------------------------------
ex  uc  far CRCS[5];
//  строка полученного CRC
//---------------------------------------------------------------------------
ex  ui  far tport;
ex  ul  far tbaud;
ex  ui  far tdata;
ex  ui  far tpart;
ex  ui  far tstop;
//  установки COM порта
//---------------------------------------------------------------------------
ex  uc  far StatCP[5][MAXSTRE];
//  строки описаний портов
//---------------------------------------------------------------------------
ex  ui  far uCMD[10];
//---------------------------------------------------------------------------
ex  _i  far xDefault;
//  флаг установки данных по умолчанию
//---------------------------------------------------------------------------
ex  _i  far xRead;
//  флаг чтения данных в любых случаях
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  MONITOR.C:
//---------------------------------------------------------------------------
ex  _i  far Monitor(vd);
//  Вывод информации о программе и подсказки программы на экран
//  Возвращаемое значение:
//               1 - было изменено значение в массиве DBB[]
//               0 - другое завершение
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  UTIL.H:
//---------------------------------------------------------------------------
ex  ui  far FBell[10];
//  Флаг звонка
//---------------------------------------------------------------------------
ex  ui  far MBuf[MBS];
//  Буфер сообщений
//---------------------------------------------------------------------------
ex  ui  far MBuA[MBA];
//  Буфер переданных сообщений (10секунд*2 (вызов раз в 2сек) = 20сек)
//---------------------------------------------------------------------------
ex  ui  far nMESSAGE;
//  Передаваемый из функции MessageOut() номер сообщения
//---------------------------------------------------------------------------
ex  uc  far FDI [HFI][MDI];
//  Массив фильтрации DI сигналов
//---------------------------------------------------------------------------
ex  uc  far FDC [HFI];
//  Указатель текущей ячейки фильтра
//---------------------------------------------------------------------------
ex  uc  far FDIO[HFI];
//  Массив предыдущих значений фильтрации
//---------------------------------------------------------------------------
ex  uc  far FNDat[100];
//  имя файла данных
//---------------------------------------------------------------------------
ex  uc  far FLBuf[SIZDBB+8];
//  Буфер чтения-записи данных массива DBB[]
//---------------------------------------------------------------------------
ex  _i  far ReadDataER;
//  Флаг ошибки чтения данных с  флэш
//---------------------------------------------------------------------------
ex  _i  far WritDataER;
//  Флаг ошибки записи данных на флэш
//---------------------------------------------------------------------------
ex  _i  far CheckValER;
//  Флаг устанавливается при переходе границы при проверке значения
//  функцией CheckVal();
//---------------------------------------------------------------------------
ex  _i  far NoCheck[MNOCHECK];
//  Массив номеров переменных DBB[], которые не подлежат проверке xCheck()
//---------------------------------------------------------------------------
ex  ui  far FDAddr[3];
//  Адреса flash для записи данных
//---------------------------------------------------------------------------
ex  _f  far AAVL[NVMAX+1][CVMAX+1];
//  Массив усреднения значений
//---------------------------------------------------------------------------
ex  ui  far AAMC[NVMAX+1];
//  Номер текущего элемента массива
//---------------------------------------------------------------------------
ex  ui  far nSOUND;
ex  ui  far pSOUND;
//  Флаги проигрывания звуков
//---------------------------------------------------------------------------
ex  uc  far CfgSTR[STRLN];
//  Строка возвращаемая функцией Config
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  UTIL.C:
//---------------------------------------------------------------------------
ex  ui  far Bell(ui far NM, ui far VB);
//  Установка флага звонка
//  NM - номер в массиве флагов звонка
//  VB - значение флага звонка
//       0- сброс флага звонка
//       1- установка флага звонка
//       2- запрос значения флага звонка
//  Возвращаемое значение:
//       0|1- текущее значение флага звонка
//---------------------------------------------------------------------------
ex  _i  far Message(ui far n, ui far k);
//  Запись номера сообщения для передачи в программу оператора.
//  Номера сообщений заносятся в буфер MBuf[], откуда функцией
//  MessageOut() через переменную nMESSAGE передаются в программу пользоват.
//  n - номер сообщения
//  k - флаг квитирования (0=не ждать, 1-ждать определённое время...)
//  Возврат: 0=сообщение отправлено, 1=сообщение в буфере, 
//  2=сообщение в буфере квитирования, 3=нет свободных ячеек(сообщение не отправлено)
//---------------------------------------------------------------------------
ex  vd  far MessageOut(vd);
//  Передача номера сообщения из буфера номеров сообщений MBuf[]
//  в переменную обмена с программой пользователя nMESSAGE.
//  Данная функция вызывается из функции main() раз в две секунды
//--------------------------------------------------------------------------
ex  vd  far MessageCLS(vd);
//  Очистка буфера сообщений MBuf[]
//--------------------------------------------------------------------------
ex  ui  far Control_AI(_f far Val,_f far VMin,_f far VMax,ui far VF,ui far VMinMes,ui far VNorMes,ui far VMaxMes,ui far BN, ui far BV);
//  Контроль AI парамметров по установленным MIN-MAX пределам
//  Val    - текущее значение
//  VMin   - минимальная граница
//  VMax   - максимальная граница
//  VF     - флаг состояния (0-Min,1-Nor,2-Max)
//  VMinMes, VNorMes, VMaxMes - номера сообщений для соответствующих состояний
//  BN     - номер звонка
//  BV     - значение флага звонка
//  Возвращаемое значение: флаг состояния:
//      0  - выход за минимальную  границу
//      1  - значение в диапозоне  нормы
//      2  - выход за максимальную границу
//---------------------------------------------------------------------------
ex  ui  far Control_DI(ui far CurDI, ui far LstDI, ui far Mess_ON, ui far Mess_OFF);
//  Контроль DI парамметров
//  CurDI    -  текущий сигнал
//  LstDI    -  сигнал  с предыдущего цикла
//  Mess_ON  -  номер сообщения если 1 (включено)
//  Mess_OFF -  номер сообщения если 0 (выключено)
//  MesLev   -  уровень вывода сообщений
//  Возвращаемое значение: текущее состояние определенного DI параметра
//---------------------------------------------------------------------------
ex  ui  far BFiltr(ui far NF, ui far CVal, ui far HCell);
//  Фильтрация дискретных входных сигналов (DI)
//  NF    - номер фильтра
//  CVal  - текущее значение сигнала
//  HCell - количество ячеек используемых для фильтрации (max=MDI (70))
//  Возвращаемое значение:
//---------------------------------------------------------------------------
ex  _f  far AISet(ui far NV,_f far CV,_f far LW,_f far HW,_f far LD,_f far HD,_f far TF,_f far SF);
//  Преобразование выходной шкалы к нужному диапазону
//  NV  - номер переменной преобразования
//  CV  - текущее показание с преобразователя
//  LW  - нижняя  граница входного диапазона
//  HW  - верхняя граница входного диапазона
//  LD  - нижняя  граница возвращаемого диапазона
//  HD  - верхняя граница возвращаемого диапазона
//  TF  - время фильтрации (сек)
//  SF  - минимальное значение фильтра при резких изменениях текущего значен
//  Возвращаемое значение:
//        значение приведенное к указанному диапазону
//---------------------------------------------------------------------------
ex  _f  far MDivF(_f far MDF1,_f far MDF2);
//  Деление переменных типа float
//---------------------------------------------------------------------------
ex  _i  far MDivI(_i far MDI1,_i far MDI2);
//  Деление переменных типа int
//---------------------------------------------------------------------------
ex  _c  far *ftostrx(_f far Value);
//  Преобразование переменной типа float в 16-тиричную строку символов
//  Возвращаемое значение: строка символов
//---------------------------------------------------------------------------
ex  _f  far CheckVal(_f far Value, _f far LVal, _f far HVal);
//  Проверка текущего значения на выход за нижнюю и верхнюю границы
//  Возвращает текущее значение
//---------------------------------------------------------------------------
ex  _i  far EraseData(ui far addr);
//  Стерание с flash данных программы
//  Возвращаемые коды:
//     =0: ошибк нет
//     >0: ошибка стирания flash
//---------------------------------------------------------------------------
ex  _i  far WriteData(ui far addr);
//  Запись данных из массива обмена DBB[] во флеш 7188 или в файл на диск
//  Возвращаемые коды:
//     = 0: данные записаны, ошибок нет
//     = 1: ошибка при записи 1ой копии данных на flash
//     = 2: ошибка при записи 2ой копии данных на flash
//     = 3: ошибка при записи файла
//---------------------------------------------------------------------------
ex  _i  far ReadData(ui far addr);
//  Чтение данных в массив обмена DBB[]
//---------------------------------------------------------------------------
ex  vd  far xCheckData(vd);
//  проверка данных в массиве DBB[]
//---------------------------------------------------------------------------
ex  vd  far xReadData(_i md);
//---------------------------------------------------------------------------
ex  _i  far  RADATA(uc far dsk_num, uc far hed_num, uc far cyl_num, uc far beg_sec);
//---------------------------------------------------------------------------
ex  _i  far  WADATA(uc far dsk_num, uc far hed_num, uc far cyl_num, uc far beg_sec);
//---------------------------------------------------------------------------
ex  int far  Config(char flag, char * File, char * Part, char * Var);
// Чтение и запись файла конфигурации
// flag='r' - чтение, flag='w' - запись, File - имя файла конфигурации,
// Part - [область] файла конфигурации, Var - имя переменной
// Если ошибок нет- возвращает ноль
// Возвращаемая строка записывается в глобальную переменную CfgSTR[STRLN]
//----------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  MAIN.H:
//---------------------------------------------------------------------------
ex  uc  far SYSTEMAF;
ex  _f  far AUTHCNTZ;
ex  _f  far AUTHCURC;
//---------------------------------------------------------------------------
ex  uc  far CFGFile[100];
// имя файла конфигурации
//---------------------------------------------------------------------------
ex  uc  far TmpStr[STRLN];
// временная строка обработки файла конфигурации
//---------------------------------------------------------------------------
ex  _f  far DBB[MAXDBB+2];
//  Основной массив переменных обмена
//---------------------------------------------------------------------------
ex  _f  far TLoop;
//  Количество 'пустых' циклов программы за один тик
//---------------------------------------------------------------------------
ex  _f  far TickLoops;
//  Текущий счетчик 'пустых' циклов за один тик
//---------------------------------------------------------------------------
ex  _f  far SLoop;
//  Количество 'пустых' циклов программы за одину секунду
//---------------------------------------------------------------------------
ex  _f  far SecnLoops;
//  Текущий счетчик 'пустых' циклов за одину секунду
//---------------------------------------------------------------------------
ex  ul  far CS_in_Tic;
//  Количество 'пустых' циклов (без выполнения программы) за тик
//---------------------------------------------------------------------------
ex  ul  far CS_in_mS;
//  Количество 'пустых' циклов (без выполнения программы) за одну миллисек.
//---------------------------------------------------------------------------
ex  _i  far LKey_;
ex  _i  far LastKey;
//  Код последней нажатой клавиши
//---------------------------------------------------------------------------
ex  _i  far ExitCode;
ex  ui  far ExitForLoad;
//  Код выхода из программы
//---------------------------------------------------------------------------
ex  _c  far Param[10];
//  Параметр запуска программы
//---------------------------------------------------------------------------
ex  _i  far FirstCall;
//  Счетчик циклов вызывов регуляторов
//---------------------------------------------------------------------------
ex  _i  far PrintDBG;
//---------------------------------------------------------------------------
ex  _f  far DateCmpLIB;
ex  _f  far TimeCmpLIB;
//  Дата и время компиляции
//---------------------------------------------------------------------------
ex  ui  far COM_Addr[MCOM];
//  Адреса COM портов
//---------------------------------------------------------------------------
ex  ul  far COM_Baud[MCOM];
//  Скорость для работы COM портов
//---------------------------------------------------------------------------
ex  int      far jmpret;
//  Переход из функции обработки сигналов исключительных ситуаций
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  MAIN.C:
//---------------------------------------------------------------------------
ex  vd  far main(ui argc, uc* argv[]);
//  В программе пользователя должны быть определены следующие функции:
//  vd far CPInit(vd)          - инициализации до вызова всех системных функций 
//  vd far Start (vd)          - вызывается в начале программы
//  vd far First_in_Cycle(vd)  - вызывается в начале каждого цикла программы
//  vd far Last__in_Cycle(vd)  - вызывается в конце  каждого цикла программы
//  vd far EveryCyc(vd)        - вызывается каждый цикл программы
//  vd far EveryTic(vd)        - вызывается каждый тик (18 раз в сек)
//  vd far EverySec(vd)        - вызывается каждую секунду
//  vd far End(vd)             - вызывается в конце программы
//  vd far SetZerVL  (vd)      - обнуление массива всех переменных DBB[]
//  vd far SetDefVL  (vd)      - установка значений  по умолчанию
//  _i far WriteDataP(vd)      - вызов функции записи данных на диск
//  _i far ReadDataP (vd)      - вызов функции чтения данных с диска
//---------------------------------------------------------------------------
ex  _i  far LKey(ui Mode);
//  Определение кода последней нажатой клавиши
//  Mode=  0-обнуление переменных кодов
//         1-получить  значение кода последней нажатой клавиши
//  Возвращаемое значение: ASCII код последней нажатой клавиши
//---------------------------------------------------------------------------
ex  _i  far cdecl matherr(struct exception *a);
ex  vd  far i_SIGNAL(_i far sig, _i far type);
ex  vd  far SetSIGF(vd);
ex  vd  far MainExt(vd);


//---------------------------------------------------------------------------
//  TIMER.H:
//---------------------------------------------------------------------------
ex  ul  far PubTimer;
//  Общий счетчик тиков
//---------------------------------------------------------------------------
ex  ul  far PubTimerS;
//  Максимальное значение счетчика
//---------------------------------------------------------------------------
ex  ul  far TA[MaxTT+10];
//  Массив таймеров
//---------------------------------------------------------------------------
ex  ul  far TimeDs;
ex  ul  far TimerTemp;
//  Переменные преобразования
//---------------------------------------------------------------------------
ex  _l  far CNTTO[MAXCNTTO+1];
//  Счетчик отработки таймаутов
//---------------------------------------------------------------------------
ex  _i  far CNTCU[MAXCNTTO+1];
//  Счетчик необходимых последовательных срабатываний таймера для
//  установки сигнала "таймер сработал"
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  TIMER.C:
//---------------------------------------------------------------------------
ex  ui  far Timer(ui far TN, ul far TT, ui far TE);
//  Функция таймера тиков для программы пользователя
//  Функция должна включаться в каждый цикл программы
//  TN  - номер таймера
//  TT  - время отработки таймера (кол-во счета)
//  TE  - единица счета таймера 1=tick, 2=sec, 3=min, 4=hour, 0=clear(set)
//  Возвращаемое значение:
//        0 - начальная установка счетчика
//        1 - счетчик в работе
//        2 - счетчик отработал
//        9 - неопределенная единица счета таймера
//---------------------------------------------------------------------------
ex  _i  far WeekDay(_i far y, _i far m, _i far d);
//  Определение текущего дня недели для указанной даты: y-год,m-месяц,d-день
//  Возвращает день недели: 0-понедельник,...
//---------------------------------------------------------------------------
ex  _i  far Plus__TO(_i far n);
//  Увеличить значение указанного счетчика на единицу
//---------------------------------------------------------------------------
ex  _i  far Minus_TO(_i far n);
//  Уменьшить значение указанного счетчика на единицу
//---------------------------------------------------------------------------
ex  vd  far Clear_TO(_i far n);
//  Очистить указанный счетчик
//---------------------------------------------------------------------------
ex  _i  far Check_TO(_i far n, _l far t, _f far p, uc far z, _f far v, _i far c);
//  функция проверки установки ожидаемого значения в указанной переменной
//  n  - номер счетчика
//  t  - заданное время для установки значения переменной
//  p  - проверяемое значение
//  z  - знак ставнения: '<' '=' '>' '!' (не равно) 'i' (integer=)
//  v  - ожидаемое значение
//  c  - счетчик удержания значения (сколько раз д.б. выполнено заданное
//       условие сработки счечика для установки флага "СРАБОТАНО")
//  Возвращаемое значение:
//     0 - за указанное время значение не установилось
//     1 - идет время установки значения переменной
//     2 - значение переменной установилось (счетчик сработал)
//     3 - идет удержание значения
//---------------------------------------------------------------------------


