//---------------------------------------------------------------------------
//  IPCCSCOM.H:
//---------------------------------------------------------------------------
ex  us  far THR;
ex  us  far RDR;
ex  us  far BRDL;
ex  us  far BRDH;
ex  us  far IER;
ex  us  far IIR;
ex  us  far FCR;
ex  us  far LCR;
ex  us  far MCR;
ex  us  far LSR;
ex  us  far MSR;
ex  us  far SCR;
//---------------------------------------------------------------------------
ex  ui  far DTR_RTS_OUT2;
//  DTR,RTS,OUT2 signal enable flag
//---------------------------------------------------------------------------
ex  uc  far EnableIRQ ;
ex  uc  far DisableIRQ;
//---------------------------------------------------------------------------
ex  uc  far ICTStat[MCOM];
//  Byte of the status register when sending data to the port
//---------------------------------------------------------------------------
ex  uc  far OutChar[MCOM];
//  Current byte sent to COM port
//---------------------------------------------------------------------------
ex  uc  far TempB  [MCOM];
ex  uc  far SaveB  [MCOM];
//  Temporary variables
//---------------------------------------------------------------------------
ex  uc  far COM_ReadBuff[MCOM][RBFSZ];
//  Receive Buffer
//---------------------------------------------------------------------------
ex  uc  far COM_SendBuff[MCOM][RBFSZ];
//  Transfer Buffer
//---------------------------------------------------------------------------
ex  ui  far COM_HRB [MCOM];
ex  ui  far COM_TRB [MCOM];
//  Pointer in the receive buffer
//---------------------------------------------------------------------------
ex  ui  far COM_HSB [MCOM];
//  Pointer in the transmit buffer
//---------------------------------------------------------------------------
ex  ui  far COM_CSB[MCOM];
//  Total number of characters to send in the buffer
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  IPCCSCOM.C:
//---------------------------------------------------------------------------
ex  ui  far InstallCom(ui p, ui Baud, ui Data, ui Chet, ui Stop);
//  Set a new interrupt vector for the specified COM port
//  nPort - COM port number for which the interrupt is set (1-COM1)
//---------------------------------------------------------------------------
ex  vd  far RestoreCom(ui Port);
//  Setting the old interrupt vector for COM ports
//  Port - COM port number for which the interrupt is set (1-COM1)
//---------------------------------------------------------------------------
ex  _i  far IsCom(ui Port);
//  Checking for the presence of received characters in the receive buffer
//  Return: 1 - there is data in the buffer, 0 - there is no data in the buffer
//---------------------------------------------------------------------------
ex  uc  far ReadCom(ui Port);
//  Reading data from the receive buffer
//  Return: Current character from buffer
//---------------------------------------------------------------------------
ex  vd  far COMOut(ui Port);
//  Sending characters through the specified COM port
//---------------------------------------------------------------------------
ex  int far ToComStr(ui Port, uc *Str);
//  Sending a string through the specified COM port
//  Port - COM port number for sending data (1-COM1...)
//  Str  - string to send
//  Return value:
//         1 - function completed successfully
//---------------------------------------------------------------------------
ex  int far ToComBufn(ui Port, uc Buf[RBFSZ], ui Num);
//  Sending a specified number of bytes through the specified COM port
//  Port - COM port number for sending data (1-COM1...)
//  Buf  - send buffer
//  Num  - a certain number of characters to send
//  Retun value:
//         1 - function completed successfully
//---------------------------------------------------------------------------
ex  uc  far COM_BitSelect(uc BS_Byte, ui BS_Num);
//  Extracting a specified bit from a byte
//  BS_Byte - byte value from which to extract a bit
//  BS_Num  - bit number to extract from the specified byte value
//---------------------------------------------------------------------------
ex  int far ClearCom (int Port);
//  Clearing the receive buffer for the specified COM port
//  Port - COM port number for which the receive buffer is being cleared (1-COM1)
//---------------------------------------------------------------------------
ex  vd  far COM_ClearSendBuff(ui Port);
//  Clearing the transmit buffer for the specified COM port
//  Port - COM port number for which the receive buffer is being cleared (1-COM1)
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  IPCCSTIM.C:
//---------------------------------------------------------------------------
ex  vd  far GetTime(int *hour, int *min, int *sec);
//  получить в переменные по указанным адресам текущее время
//---------------------------------------------------------------------------
ex  vd  far GetDate(int *year, int *mon, int *day);
//  получить в переменные по указанным адресам текущее время
//---------------------------------------------------------------------------
ex  vd  far SetTime(int hour, int min, int sec);
//  установить в системе время из передаваемых переменных
//---------------------------------------------------------------------------
ex  vd  far SetDate(int year, int mon, int day);
//  установить в системе дату из передаваемых переменных
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  NBFN.H:
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  NBFN.C:
//---------------------------------------------------------------------------
ex  vd  far PrintNCB(ui ncb);
//  Вывод на экран структуры NCB
//---------------------------------------------------------------------------
ex  ui  far WS_NB__Init(vd);
//  Проверка установки NETBIOS
//  Retun value:
//           0 - NetBIOS установлен
//           1 - NetBIOS не установлен
//---------------------------------------------------------------------------
ex  vd  far WS_NB__ZeroNCB(ui WS_CurNCB);
//  Заполнение значений текущего NCB нулями
//  WS_CurNCB- текущий  NCB (NetBIOS Control Block)
//---------------------------------------------------------------------------
ex  vd  far WS_NB__NetBios(ui WS_CurNCB);
//  Вызов выполнения функций NETBIOS
//  WS_CurNCB- текущий NCB
//---------------------------------------------------------------------------
ex  ui  far WS_NB__AddName(_c far *WS_name,ui WS_CurNCB);
//  Добавление имени станции в список сети NetBIOS
//  WS_name  - имя станции (до 15 символов)
//  WS_CurNCB- текущий NCB
//  Retun value:
//               0 - успешное завершение функции
//             100 - ошибка текущего NCB
//          другое - код ошибки NetBIOS
//---------------------------------------------------------------------------
ex  ui  far WS_NB__DeleteName( _c far *WS_name,ui WS_CurNCB );
//  Удаление имени станции из списка сети NetBIOS
//  WS_name  - имя станции (до 15 символов)
//  WS_CurNCB- текущий NCB
//  Retun value:
//               0 - успешное завершение функции
//             100 - ошибка текущего NCB
//          другое - код ошибки NetBIOS
//---------------------------------------------------------------------------
ex  ui  far WS_NB__GetError(vd);
//  Возврат кода ошибки
//---------------------------------------------------------------------------
ex  ui  far WS_NB__GetFinalCCode(ui WS_CurNCB);
//  Возврат завершающего кода выполнения функции NetBIOS из текущего NCB
//  WS_CurNCB- текущий NCB
//---------------------------------------------------------------------------
ex  ui  far WS_NB__GetRetCCode(ui WS_CurNCB);
ex  ui  far WS_NB__GetNCBSize(ui WS_CurNCB);
//  Возврат размера буфера обмена из текущего NCB
//  WS_CurNCB- текущий NCB
//---------------------------------------------------------------------------
ex  ui  far WS_NB__GetNetworkN(ui WS_CurNCB);
//  Возврат номера имени станции в сети из текущего NCB
//  WS_CurNCB- текущий NCB
//---------------------------------------------------------------------------
ex  _c  far *WS_NB__GetCallName(ui WS_CurNCB);
//  Возврат имени вызываемого партнера из текущего NCB
//  WS_CurNCB- текущий NCB
//---------------------------------------------------------------------------
ex  _c  far *WS_NB__GetOurName(ui WS_CurNCB);
ex  vd  far WS_NB__SetBuffer(_c far *WS_Buf, ui WS_BufSize, ui WS_CurNCB);
//  Установка адреса и размера буфера приема|передачи в текущем NCB
//  WS_Buf    - указатель на буфер обмена
//  WS_BufSize- размер буфера
//  WS_CurNCB - текущий NCB
//---------------------------------------------------------------------------
ex  vd  far WS_NB__SetCallName(_c far *WS_name, ui WS_CurNCB);
//  Установка имени вызываемой станции в текущем NCB
//  WS_name   - имя вызываемой станции
//  WS_CurNCB - текущий NCB
//---------------------------------------------------------------------------
ex  vd  far WS_NB__ReceiveDatagram(ui far WS_NetwrkNameNumber, ui WS_CurNCB);
//  Прием датаграммы
//  WS_NetwrkNameNumber - номер имени в сети
//  WS_CurNCB - текущий NCB
//---------------------------------------------------------------------------
ex  vd  far WS_NB__SendDatagram(ui far WS_NetwrkNameNumber, ui WS_CurNCB);
//  Посылка датаграммы
//  WS_NetwrkNameNumber - номер имени в сети
//  WS_CurNCB - текущий NCB
//---------------------------------------------------------------------------
ex  vd  far WS_NB__Receive(_c far *WS_Buffer_Name, ui WS_Buffer_Size,ui WS_NetworkNameNumber, ui WS_CurNCB);
//  Прием данных из сети NetBIOS
//  WS_Buffer_Name - буфер обмена для текущего NCB
//  WS_Buffer_Size - размер буфера обмена
//  WS_NetworkNameNumber -  номер имени станции в сети
//  WS_CurNCB      - номер текущего NCB
//---------------------------------------------------------------------------
ex  vd  far WS_NB__Send(_c far *WS_Buffer_Name, ui WS_Buffer_Size,_c far *WS_Station, ui WS_NetworkNameNumber, ui WS_CurNCB);
//  Посылка данных в сети NetBIOS
//  WS_Buffer_Name - буфер обмена для текущего NCB
//  WS_Buffer_Size - размер буфера обмена
//  WS_Station     - имя вызываемой станции
//  WS_NetworkNameNumber -  номер имени станции в сети
//  WS_CurNCB      - номер текущего NCB
//---------------------------------------------------------------------------
ex  vd  far WS_NB__Reset(ui WS_Adapter, ui WS_CurNCB);
//  Сброс установок NetBIOS
//  WS_Adapter - номер сетевого адаптера для которого сбрасываются установки
//  WS_CurNCB  - номер текущего NCB
//---------------------------------------------------------------------------
ex  vd  far WS_NB__Cancel(ui WS_CurNCB);
//  Отмена последней команды Send__ NetBIOS
//  WS_CurNCB  - номер текущего NCB
//---------------------------------------------------------------------------
ex  _i  far WS_NB__AvNCB(vd);
//  Возвращает номер свободного NCB или -1, если свободного NCB нет
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  NBWS.H:
//---------------------------------------------------------------------------
ex  ui  far NBStat;
//---------------------------------------------------------------------------
ex  _c  far WS_LocalS[LNAM];
ex  _c  far WS_NBName[LNAM];
//---------------------------------------------------------------------------
ex  _l far CNTANS;


//---------------------------------------------------------------------------
//  NBWS.C:
//---------------------------------------------------------------------------
ex  vd  far WS_NB_SetNumber(_c far * WSNBNS);
ex  vd  far WS_NB__NetChange(vd);
//  Обмен данными в сети NetBIOS
//--------------------------------------------------------------------------
ex  vd  far WS_NB__Answer(ui inncb, ui ouncb);
//  Формирование ответного блока для сетевого ответа
//  n - номер текущего NCB
//---------------------------------------------------------------------------
ex  vd  far WS_NB__GetFromNet(ui n);
//  Передача принятых из сети данных в массив обмена DBB[]
//  n - номер текущего NCB
//--------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  REGUL.H:
//---------------------------------------------------------------------------
ex  _f  far WO_Skip[NREGUL];
// Возвращаемое регулятором значение для передачи в программу пользователя
// (для 'безударного' перехода регулятора в ручной и автоматический  режимы)
//---------------------------------------------------------------------------
ex  _f  far OutX[NREGUL];
ex  _f  far OutO[NREGUL];
// выход регулятора из аналоговой части
//---------------------------------------------------------------------------
ex  _f  far OutR[NREGUL];
// разница между предыдущим и текущим выходом регулятора
//---------------------------------------------------------------------------
ex  _f  far ImpPC[NREGUL];
// счетчик длинны импульса
//---------------------------------------------------------------------------
ex  _f  far ImpWC[NREGUL];
// счетчик длинны паузы между импульсами
//---------------------------------------------------------------------------
ex  _i  far RetO[NREGUL];
// дискретный выход регулятора с прошлого шага
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  REGUL.C:
//---------------------------------------------------------------------------
ex  vd  far RegulatorInit(vd);
//  Обнуление флагов регуляторов
//---------------------------------------------------------------------------
ex  _f  far Regulator(ui n,_f Inp,_f KP,_f KI,_f KD,_f TI,_f KO,ui KA,_f ZL,_f ZH,_f IL,_f IH,_f OL,_f OH,_f DM,_f ZN,_f PR,ui CC,ui FL);
//  n       номер регулятора
//  Inp     текущее значение регулируемого параметра
//  KP,KI,KD,TI   коэф.регул KP-пропорц,KI-интегр,KD-дифференц,TI-время изодрома
//  KO      ручное управление
//  KA      переключение ручное-автомат (1-автомат,0-ручное)
//  ZL,ZH   задание регулятора
//  IL,IH   входная шкала регулятора  (шкала регулируемого параметра)
//  OL,OH   выходная шкала регулятора
//  DM      MAX приращение регулятора
//  ZN      зона нечуствительности
//  PR      процент рассогласования для включения контрольного цикла
//  CC      контрольный цикл (ч/з сколько циклов будет включаться контр.цикл)
//  FL      тип регулятора
//          5 - только текущий шаг регулятора (рассогласование без приращения)
//  Retun value:
//          выход регулятора
//---------------------------------------------------------------------------
ex  _i  far RegulDigit(ui n, _f KDP, _f KDW, _f KMas, _i ModRA, _i OutM);
//  Преобразование аналогового выхода в дискретный
//  n    - номер регулятора
//  KDP  - коэффициент длинны импульса
//  KDW  - коэффициент длинны паузы
//  KMas - коэффициент масштаба
//  ModRA- режим работы регулятора (ручное-автомат)
//  OutM - выход ручного управления регулятора
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  IMOD.H:
//---------------------------------------------------------------------------
ex  ui  far HMCF[MCOM];
//  количество записей описаний модулей
//---------------------------------------------------------------------------
ex  uc  far PCCA[4];
//  адрес контроллера в сети
//---------------------------------------------------------------------------
ex  ui  far RecvTO [MCOM];
ex  ui  far RecvCmd[MCOM];
//  флаг приема данных из порта (когда идет прием данных из портов
//  COM1|COM2|COM3|COM4 порядковый номер флага устанавливается в 1 и более)
//---------------------------------------------------------------------------
ex  ui  far SendTO [MCOM];
ex  ui  far COMWT  [MCOM];
//  Текущее значение паузы (циклов) между посылками в порт
//---------------------------------------------------------------------------
ex  ui  far COMTO  [MCOM];
//  количество циклов таймаута опроса модулей
//---------------------------------------------------------------------------
ex  ui  far COMCH  [MCOM];
//  флаги использования портов
//  0-порт не используется (NOU)
//  1-порт используется для обмена с модулями УСО (USO)
//  2-порт используется для обмена с рабочими станциями в режиме SLAVE (WST)
//---------------------------------------------------------------------------
ex  ui  far HEXF[MCOM];
//  флаг приема от AI модулей ответов HEX или % формате (1=HEX)
//---------------------------------------------------------------------------
ex  uc  far ReadBF [MCOM][RBFSZ];
ex  uc  far SendBT [MCOM][RBFSZ];
ex  uc  far TempBF [MCOM][14];
//  буфер для приема данных (запросов)
//---------------------------------------------------------------------------
ex  ui  far ReadCB [MCOM];
ex  ui  far SendCB [MCOM];
//  номер текущего байта в буфере чтения
//---------------------------------------------------------------------------
ex  ui  far ReadED [MCOM];
//  флаг окончания чтения данных из порта
//---------------------------------------------------------------------------
ex  ui  far VAGIFLG[MCOM];
//  флаг работы с прибором ВАГИ
//---------------------------------------------------------------------------
ex  ui  far VAGICNT[MCOM];
//  счетчик текущего символа ответа от прибора ВАГИ
//---------------------------------------------------------------------------
ex  uc  far VAGISTR[MCOM][VAGSLEN];
//  строки ответов от приборов
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  IMOD.C:
//---------------------------------------------------------------------------
ex  vd  far WS_SP_SetNumber(_c * WSSPNS);
//  установка номера рабочей станции для сети RS485
//--------------------------------------------------------------------------
ex  vd  far CheckTimeOut(ui p);
//  проверка таймаута ответа от COM порта
//---------------------------------------------------------------------------
ex  ui  far CheckCRC(ui p);
//  проверка CRC (1-совпадает, 0-нет)
//---------------------------------------------------------------------------
ex  vd  far ConvertRead(ui p);
//  преобразование ответов от модулей УСО
//---------------------------------------------------------------------------
ex  vd  far SendCMD(ui p);
//  посылка комманд на модули УСО
//---------------------------------------------------------------------------
ex  vd  far ClearR(_i p);
ex  vd  far ClearS(_i p);
ex  vd  far ReadANS(ui p);
//  прием ответов от модулей УСО и запросов от рабочих станций
//---------------------------------------------------------------------------
ex  ui  far TestREQ(ui p);
//  Прием данных от рабочей станции и ответ на запрос (если был запрос)
//---------------------------------------------------------------------------
ex  _i  far SetMODV(uc p, uc r, uc c,  _f v,  _f ld, _f hd);
//  Установить значение на указанном канале:
//  p     - номер COM-порта
//  r     - номер записи в массиве определений модулей
//  c     - номер ячейки в записи
//  v     - устанавливаемое значение (0-100%)
//  ld,hd - нижняя и верхняя границы диапазона выхода в %
//          (0..25% - 0..5mA, 20..100% - 4..20mA, 0..100% - 0..20mA)
//---------------------------------------------------------------------------
ex  _i  far SetMODC(ui p, ui r, ui t, uc *c, ui l, ui a);
//  p  - номер COM порта
//  r  - номер записи для массива определения модулей
//  t  - тип модуля
//  c  - комманда для модуля
//  l  - длинна комманды
//  a  - количество переменных ответов
//  Возврат: 0-нет ошибок в установке, меньше 0- есть ошибки...
//---------------------------------------------------------------------------
ex  _i  far SetMODF(ui p, ui r, uc f, _i v);
//  p  - COM порт
//  r  - номер записи в массиве определения модулей
//  f  - устанавливаемое поле 'e'-ошибок, 'o'-правильных ответов
//  v  - значение для устанавливаемого поля
//  Возвращает 0, если значение установленно или -1, если
//  установки определены неверно
//---------------------------------------------------------------------------
ex  _i  far GetMODF(ui p, ui r, uc f);
//  p  - COM порт
//  r  - номер записи в массиве определения модулей
//  f  - запрашиваемое поле 'e'-ошибки, 'o'-правильные ответы
//  Возвращает значение запрашиваемого поля указанной  записи или -1,
//  если установки определены неверно
//---------------------------------------------------------------------------
ex  _f  far GetMODV(ui p, ui r, uc n);
//  p  - COM порт
//  r  - номер записи в массиве определения модулей
//  n  - номер переменной из массива определения модулей (номер канала модуля)
//  Возвращает значение запрашиваемого канала модуля
//---------------------------------------------------------------------------
ex  _i  far PrnMODC(ui p, ui r, ui m);
//  p  - COM порт
//  r  - номер записи в массиве определения модулей
//  m  - режим вывода информации
//  Выводит информацию о конфигурации модуля указанной записи
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  MONITOR.H:
//---------------------------------------------------------------------------
ex  _i  far MonCHN[20];
//  Номера каналов для отображения
//---------------------------------------------------------------------------
ex  _i  far MonFirst;
//  Флаг первого вызова монитора
//---------------------------------------------------------------------------
ex  _i  far MonCPos;
//  Текущая позиция в буфере ввода комманды
//---------------------------------------------------------------------------
ex  uc  far SCMD[MAXSTRE];
ex  _c  far pVERSION[MAXSTRE];
ex  _c  far nVERSION[MAXSTRE];
//---------------------------------------------------------------------------
ex  ui  far BusyTer;
//  флаг занятости порта
//---------------------------------------------------------------------------
ex  ui  far AddrrBeg;
ex  ui  far AddrrEnd;
//  адрес модулей для поиска
//---------------------------------------------------------------------------
ex  ui  far CRCF[5];
//  флаги разрешения учета контрольных сумм в терминальных операциях
//---------------------------------------------------------------------------
ex  uc  far CRCS[5];
//  строка полученного CRC
//---------------------------------------------------------------------------
ex  ui  far tport;
ex  ul  far tbaud;
ex  ui  far tdata;
ex  ui  far tpart;
ex  ui  far tstop;
//  установки COM порта
//---------------------------------------------------------------------------
ex  uc  far StatCP[5][MAXSTRE];
//  строки описаний портов
//---------------------------------------------------------------------------
ex  ui  far uCMD[10];
//---------------------------------------------------------------------------
ex  _i  far xDefault;
//  флаг установки данных по умолчанию
//---------------------------------------------------------------------------
ex  _i  far xRead;
//  флаг чтения данных в любых случаях
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  MONITOR.C:
//---------------------------------------------------------------------------
ex  _i  far Monitor(vd);
//  Вывод информации о программе и подсказки программы на экран
//  Retun value:
//               1 - было изменено значение в массиве DBB[]
//               0 - другое завершение
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  UTIL.H:
//---------------------------------------------------------------------------
ex  ui  far FBell;
//  Флаг звонка
//---------------------------------------------------------------------------
ex  ui  far HM;
//  Указатель буфера сообщений MBuf[] функции Message()
//---------------------------------------------------------------------------
ex  ui  far TM;
//  Указатель буфера сообщений MBuf[] функции MessageOut()
//---------------------------------------------------------------------------
ex  ui  far MBuf[MBS];
//  Буфер сообщений
//---------------------------------------------------------------------------
ex  ui  far nMESSAGE;
//  Передаваемый из функции MessageOut() номер сообщения
//---------------------------------------------------------------------------
ex  uc  far FDI [HFI][MDI];
//  Массив фильтрации DI сигналов
//---------------------------------------------------------------------------
ex  uc  far FDC [HFI];
//  Указатель текущей ячейки фильтра
//---------------------------------------------------------------------------
ex  uc  far FDIO[HFI];
//  Массив предыдущих значений фильтрации
//---------------------------------------------------------------------------
ex  uc  far FNDat[40];
//  имя файла данных
//---------------------------------------------------------------------------
ex  uc  far FLBuf[SIZDBB+8];
//  Буфер чтения-записи данных массива DBB[]
//---------------------------------------------------------------------------
ex  _i  far ReadDataER;
//  Флаг ошибки чтения данных с  флэш
//---------------------------------------------------------------------------
ex  _i  far WritDataER;
//  Флаг ошибки записи данных на флэш
//---------------------------------------------------------------------------
ex  _i  far CheckValER;
//  Флаг устанавливается при переходе границы при проверке значения
//  функцией CheckVal();
//---------------------------------------------------------------------------
ex  _i  far NoCheck[MNOCHECK];
//  Массив номеров переменных DBB[], которые не подлежат проверке xCheck()
//---------------------------------------------------------------------------
ex  ui  far FDAddr[3];
//  Адреса flash для записи данных
//---------------------------------------------------------------------------
ex  _f  far AAVL[NVMAX+1][CVMAX+1];
//  Массив усреднения значений
//---------------------------------------------------------------------------
ex  ui  far AAMC[NVMAX+1];
//  Номер текущего элемента массива
//---------------------------------------------------------------------------
ex  ui  far nSOUND;
ex  ui  far pSOUND;
//  Флаги проигрывания звуков
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  UTIL.C:
//---------------------------------------------------------------------------
ex  ui  far Bell(ui VB);
//  Установка флага звонка
//  VB - значение флага звонка
//       0- сброс флага звонка
//       1- установка флага звонка
//       2- запрос значения флага звонка
//  Retun value:
//       0|1- текущее значение флага звонка
//---------------------------------------------------------------------------
ex  vd  far Message(ui n);
//  Генерация номера сообщения для передачи в программу оператора.
//  Номера генерируемых сообщений заносятся в буфер MBuf[], откуда функцией
//  MessageOut() через переменную nMESSAGE передаются в программу пользоват.
//  n - номер сообщения
//---------------------------------------------------------------------------
ex  vd  far MessageOut(vd);
//  Передача номера сообщения из буфера номеров сообщений MBuf[]
//  в переменную обмена с программой пользователя nMESSAGE.
//  Данная функция вызывается из функции main() раз в две секунды
//--------------------------------------------------------------------------
ex  vd  far MessageCLS(vd);
//  Очистка буфера сообщений MBuf[]
//--------------------------------------------------------------------------
ex  ui  far Control_AI(_f Val,_f VMin,_f VMax,ui VF,ui VMinMes,ui VNorMes,ui VMaxMes,ui BN);
//  Контроль AI парамметров по установленным MIN-MAX пределам
//  Val    - текущее значение
//  VMin   - минимальная граница
//  VMax   - максимальная граница
//  VF     - флаг состояния (0-Min,1-Nor,2-Max)
//  VMinMes, VNorMes, VMaxMes - номера сообщений для соответствующих состояний
//  BN     - значение флага звонка
//  Retun value: флаг состояния:
//      0  - выход за минимальную  границу
//      1  - значение в диапозоне  нормы
//      2  - выход за максимальную границу
//---------------------------------------------------------------------------
ex  ui  far Control_DI(ui CurDI, ui LstDI, ui Mess_ON, ui Mess_OFF);
//  Контроль DI парамметров
//  CurDI    -  текущий сигнал
//  LstDI    -  сигнал  с предыдущего цикла
//  Mess_ON  -  номер сообщения если 1 (включено)
//  Mess_OFF -  номер сообщения если 0 (выключено)
//  MesLev   -  уровень вывода сообщений
//  Retun value: текущее состояние определенного DI параметра
//---------------------------------------------------------------------------
ex  ui  far BFiltr(ui NF, ui CVal, ui HCell);
//  Фильтрация дискретных входных сигналов (DI)
//  NF    - номер фильтра
//  CVal  - текущее значение сигнала
//  HCell - количество ячеек используемых для фильтрации (max=MDI (70))
//  Retun value:
//---------------------------------------------------------------------------
ex  _f  far AISet(ui NV,_f CV,_f LW,_f HW,_f LD,_f HD,_f TF,_f SF);
//  Преобразование выходной шкалы к нужному диапазону
//  NV  - номер переменной преобразования
//  CV  - текущее показание с преобразователя
//  LW  - нижняя  граница входного диапазона
//  HW  - верхняя граница входного диапазона
//  LD  - нижняя  граница возвращаемого диапазона
//  HD  - верхняя граница возвращаемого диапазона
//  TF  - время фильтрации (сек)
//  SF  - минимальное значение фильтра при резких изменениях текущего значен
//  Retun value:
//        значение приведенное к указанному диапазону
//---------------------------------------------------------------------------
ex  _f  far MDivF(_f MDF1,_f MDF2);
//  Деление переменных типа float
//---------------------------------------------------------------------------
ex  _i  far MDivI(_i MDI1,_i MDI2);
//  Деление переменных типа int
//---------------------------------------------------------------------------
ex  _c  far *ftostrx(_f Value);
//  Преобразование переменной типа float в 16-тиричную строку символов
//  Retun value: строка символов
//---------------------------------------------------------------------------
ex  _f  far CheckVal(_f Value, _f LVal, _f HVal);
//  Проверка текущего значения на выход за нижнюю и верхнюю границы
//  Возвращает текущее значение
//---------------------------------------------------------------------------
ex  _i  far EraseData(ui addr);
//  Стерание с flash данных программы
//  Возвращаемые коды:
//     =0: ошибк нет
//     >0: ошибка стирания flash
//---------------------------------------------------------------------------
ex  _i  far WriteData(ui addr);
//  Запись данных из массива обмена DBB[] во флеш 7188 или в файл на диск
//  Возвращаемые коды:
//     = 0: данные записаны, ошибок нет
//     = 1: ошибка при записи 1ой копии данных на flash
//     = 2: ошибка при записи 2ой копии данных на flash
//     = 3: ошибка при записи файла
//---------------------------------------------------------------------------
ex  _i  far ReadData(ui addr);
//  Чтение данных в массив обмена DBB[]
//---------------------------------------------------------------------------
ex  vd  far xCheckData(vd);
//  проверка данных в массиве DBB[]
//---------------------------------------------------------------------------
ex  vd  far xReadData(_i md);
//---------------------------------------------------------------------------
ex  _i  far  RADATA(uc dsk_num, uc hed_num, uc cyl_num, uc beg_sec);
//---------------------------------------------------------------------------
ex  _i  far  WADATA(uc dsk_num, uc hed_num, uc cyl_num, uc beg_sec);
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  MAIN.H:
//---------------------------------------------------------------------------
ex  _f  far DBB[MAXDBB+2];
//  Основной массив переменных обмена
//---------------------------------------------------------------------------
ex  _f  far TLoop;
//  Количество 'пустых' циклов программы за один тик
//---------------------------------------------------------------------------
ex  _f  far TickLoops;
//  Текущий счетчик 'пустых' циклов за один тик
//---------------------------------------------------------------------------
ex  _f  far SLoop;
//  Количество 'пустых' циклов программы за одину секунду
//---------------------------------------------------------------------------
ex  _f  far SecnLoops;
//  Текущий счетчик 'пустых' циклов за одину секунду
//---------------------------------------------------------------------------
ex  ul  far CS_in_Tic;
//  Количество 'пустых' циклов (без выполнения программы) за тик
//---------------------------------------------------------------------------
ex  ul  far CS_in_mS;
//  Количество 'пустых' циклов (без выполнения программы) за одну миллисек.
//---------------------------------------------------------------------------
ex  _i  far LKey_;
ex  _i  far LastKey;
//  Код последней нажатой клавиши
//---------------------------------------------------------------------------
ex  _i  far ExitCode;
ex  ui  far ExitForLoad;
//  Код выхода из программы
//---------------------------------------------------------------------------
ex  _c  far Param[10];
//  Параметр запуска программы
//---------------------------------------------------------------------------
ex  _i  far FirstCall;
//  Счетчик циклов вызывов регуляторов
//---------------------------------------------------------------------------
ex  _i  far PrintDBG;
//---------------------------------------------------------------------------
ex  _f  far DateCmpLIB;
ex  _f  far TimeCmpLIB;
//  Дата и время компиляции
//---------------------------------------------------------------------------
ex  ui  far COM_Addr[MCOM];
//  Адреса COM портов
//---------------------------------------------------------------------------
ex  ul  far COM_Baud[MCOM];
//  Скорость для работы COM портов
//---------------------------------------------------------------------------
ex  int      far jmpret;
//  Переход из функции обработки сигналов исключительных ситуаций
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  MAIN.C:
//---------------------------------------------------------------------------
ex  vd  far main(vd);
//  В программе пользователя должны быть описаны следующие функции:
//  vd far Start(vd)           - вызывается в начале программы
//  vd far First_in_Cycle(vd)  - вызывается в начале каждого цикла программы
//  vd far EveryCyc(vd)        - вызывается каждый цикл программы
//  vd far EveryTic(vd)        - вызывается каждый тик
//  vd far EverySec(vd)        - вызывается каждую секунду
//  vd far Last__in_Cycle(vd)  - вызывается в конце каждого цикла программы
//  vd far End(vd)             - вызывается в конце программы
//---------------------------------------------------------------------------
ex  _i  far LKey(ui Mode);
//  Определение кода последней нажатой клавиши
//  Mode=  0-обнуление переменных кодов
//         1-получить  значение кода последней нажатой клавиши
//  Retun value: ASCII код последней нажатой клавиши
//---------------------------------------------------------------------------
ex  _i  cdecl matherr(struct exception *a);
ex  vd  far i_SIGNAL(_i sig, _i type);
ex  vd  far SetSIGF(vd);
ex  vd  far MainExt(vd);


//---------------------------------------------------------------------------
//  TIMER.H:
//---------------------------------------------------------------------------
ex  ul  far PubTimer;
//  Общий счетчик тиков
//---------------------------------------------------------------------------
ex  ul  far PubTimerS;
//  Максимальное значение счетчика
//---------------------------------------------------------------------------
ex  ul  far TA[MaxTT+10];
//  Массив таймеров
//---------------------------------------------------------------------------
ex  ul  far TimeDs;
ex  ul  far TimerTemp;
//  Переменные преобразования
//---------------------------------------------------------------------------
ex  ui  far YEAR[12];
ex  ui  far DAYR[12];
ex  ui  far MONR[12];
//  Пеменные для вычисления дня недели
//---------------------------------------------------------------------------
ex  _l  far CNTTO[MAXCNTTO+1];
//  Счетчик отработки таймаутов
//---------------------------------------------------------------------------
ex  _i  far CNTCU[MAXCNTTO+1];
//  Счетчик необходимых последовательных срабатываний таймера для
//  установки сигнала "таймер сработал"
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//  TIMER.C:
//---------------------------------------------------------------------------
ex  ui  far Timer(ui TN, ul TT, ui TE);
//  Функция таймера тиков для программы пользователя
//  Функция должна включаться в каждый цикл программы
//  TN  - номер таймера
//  TT  - время отработки таймера (кол-во счета)
//  TE  - единица счета таймера 1=tick, 2=sec, 3=min, 4=hour, 0=clear(set)
//  Retun value:
//        0 - начальная установка счетчика
//        2 - счетчик отработал
//        9 - неопределенная единица счета таймера
//---------------------------------------------------------------------------
ex  _i  far WeekDay(_i y, _i m, _i d);
//  Определение текущего дня недели для указанной даты: Y-год,m-месяц,d-день
//  Возвращает день недели: 0-понедельник,...
//---------------------------------------------------------------------------
ex  _i  far Plus__TO(_i n);
//  Увеличить значение указанного счетчика на единицу
//---------------------------------------------------------------------------
ex  _i  far Minus_TO(_i n);
//  Уменьшить значение указанного счетчика на единицу
//---------------------------------------------------------------------------
ex  vd  far Clear_TO(_i n);
//  Очистить указанный счетчик
//---------------------------------------------------------------------------
ex  _i  far Check_TO(_i n, _l t, _f p, uc z, _f v, _i c);
//  функция проверки установки ожидаемого значения в указанной переменной
//  n  - номер счетчика
//  t  - заданное время для установки значения переменной
//  p  - проверяемое значение
//  z  - знак ставнения: '<' '=' '>' '!' (не равно) 'i' (integer=)
//  v  - ожидаемое значение
//  c  - счетчик удержания значения (сколько раз д.б. выполнено заданное
//       условие сработки счечика для установки флага "СРАБОТАНО")
//  Retun value:
//     0 - за указанное время значение не установилось
//     1 - идет время установки значения переменной
//     2 - значение переменной установилось (счетчик сработал)
//     3 - идет удержание значения
//---------------------------------------------------------------------------


